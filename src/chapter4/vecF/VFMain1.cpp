#include <iostream>
using namespace std;
#include "VecF.h"  

int main()
{
    /*
    float a[3] = {1, 2, 3};
    VecF v1(3,a); //1, 2, 3 을 저장하는 벡터
    VecF v2(v1); // v1을 복사하여 v2 를 만듦
    v1.print();
    cout << endl;
    v2.print();
    cout << endl;
    return 0;
    */
   float a[3] = { 1, 2, 3 };
   float b[3] = { 2, 4, 6 };
   VecF v1(3,a);
   VecF v2(3,b);
   VecF v3(v1.add(v2));
   v1.print();
   cout << " + ";
   v2.print();
   cout << " = ";
   v3.print();
   cout << endl;
   return 0;
}
//8행에서 3개의 float값을 저장할 공간을 할당하고 , 매개변수로 전달된 배열의 값 1, 2, 3을 저장하여 v1이 생성된다.
//그 다음 9행에 의해 v1을 복사하여 v2를 만든다. 그런데 컴파일러가 묵시적으로 만드는 복사 생성자는 데이터 멤버를 그대로 복사하는것 외에 다른 처리는 하지
//않으므로 v2의 arr은 v1의 arr을 그대로 복사한다. 이때 arr은 포인터이므로 이 복사에 의해 v2 arr은 v1의 arr이 가리키는 공간을 함께 가리키는 것으로 처리된다.
// 이러한 복사를 얕은복사(shallow copy)라고 한다. 이 상태에서 10행 및 12행 처럼 print를 호출하여 출력하면 데이터를 올바르게 출력하며, 이상이 있는것으로
// 보이지는 않는다. 문제는 객체의 소멸자가 동작할 때 발생한다. v1과 v2는 별개의 객체처럼 보이지만, 사실은 데이터를 저장하는 공간을 함께 가리키므로 완전히 별개의 객체라고 할 수 없다.
// main() 함수의 종료시점이 되면 지역변수인 객체 v1과 v2가 제거되며, 이때 소멸자가 동작한다. 소멸자에서는 arr이 가리키는 공간을 반납한다.
// 만일 v1이 먼저 제거되는 대상이라면 v1의 arr이 가리키는 공간이 반납된 후 v1이 제거된다. 이 상태에서 v2의 소멸자가 동작하면 v2의 arr이 가리키는 공간을
// 반납하려 할 것이다. 그런데 v2의 arr이 가리키는 공간은 이미 v1의 소멸자를 통해 반납되어 더 이상 이 프로그램의 영역이 아니다. 그러므로 이 반납명령은 
// 거부되며, 그 결과 에러가 발생하는 것이다.
// 이 문제를 해결하는 방법은 클래스 VecF에 복사 생성자를 명시적으로 선언하되, arr이 가리킬 공간을 별도로 할당하고 내용을 복사하게 하는 것이다.
// 이러한 복사를 깊은 복사(deep copy) 라고 한다.